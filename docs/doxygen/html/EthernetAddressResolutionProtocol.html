<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Snorlax Protocol Stack: An Ethernet Address Resolution Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Snorlax Protocol Stack
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Snorlax Protocol Stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">An Ethernet Address Resolution Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Notes">Notes</a></li>
<li class="level1"><a href="#TheProblem">The Problem</a></li>
<li class="level1"><a href="#Motivation">Motivation</a></li>
<li class="level1"><a href="#Definitions">Definitions</a></li>
<li class="level1"><a href="#PacketFormat">Packet Format</a></li>
<li class="level1"><a href="#PacketGeneration">Packet Generation</a></li>
<li class="level1"><a href="#PacketReception">Packet Reception</a></li>
<li class="level1"><a href="#Why_is_it_done_This_way">Why is it done this way?</a></li>
<li class="level1"><a href="#NetworkMonitoring_and_Debugging">Network Monitoring and Debugging</a></li>
<li class="level1"><a href="#Example">An Example</a></li>
<li class="level1"><a href="#RelatedIssue">Related Issue</a></li>
</ul>
</div>
<div class="textblock"><p>The implementation of protocol P on a sending host S decides, through protocol P's routing mechanism, that is wants to transmit to a target host T located some place on an connected piece of 10Mbit Ethernet cable. To actually transmit the Ethernet packet a 48.bit Ethernet address must be generated. The addresses of hosts within protocol P are not always compatible with the corresponding Ethernet address (being different lengths or values). Presented here is a protocol that allows dynamic distribution of the information needed to build tables to translate an address A in protocol P's address space into a 48.bit Ethernet address.</p>
<p>Generalizations have been made which allow the protocol to be used for non-10Mbit Ethernet hardware. Some packet radio networks are examples of such hardware.</p>
<h1><a class="anchor" id="Notes"></a>
Notes</h1>
<p>This protocol was originally designed for the DEC/Intel/Xerox 10Mbit Ethernet. It has been generalized to allow it to be used for other types of networks. Much of the discussion will be directed toward the 10Mbit Ethernet. Generalizations, where applicable, will follow the Ethernet-specific discussion.</p>
<p>DOD Internet Protocol will be referred to as Internet.</p>
<p>Numbers here are in the Ethernet standard, which is high byte first. This is the oppsite of the byte addressing of machines such as PDP-11s and VAXes. Therefore, special care must be taken with the opcode field (ar$op) described below.</p>
<h1><a class="anchor" id="TheProblem"></a>
The Problem</h1>
<p>The world is a jungle in general, and the networking game contributes many animals. At nearly every layer of a network architecture there are several potential protocols that could be used. For example, at a high level there is TELNET and SUPDUP for remote login. Somewhere below that there is a reliable byte stream protocol, which might be CHAOS protocol, DOD TCP, Xerox stream protocol, which might be CHAOS protocol, DOD TCP, Xerox BSP or DECnet. Even closer to the hardware is the logical transport layer, which might be CHAOS, DOD Internet, Xerox PUP, or DECnet. The 10Mbit Ethernet allows all of these protocols (and more) to coexist on a single cable by means of a type field in the Ethernet packet header. However, the 10Mbit Ethernet requires 48 bit addresses on the physical cable, yet most protocol addresses are not 48.bits long, nor do they necessarily have any relationship to the 48 bit Ethernet address of the hardware. For xample, CHAOS addresses 16.bits, DOD Internet addresses are 32.bits, and Xerox PUP addresses are 8.bits. A protocol is needed to dynamically distribute the correspondences between a &lt;protocol, address&gt; pair and a 48.bit Ethernet address.</p>
<h1><a class="anchor" id="Motivation"></a>
Motivation</h1>
<p>Use of the 10Mbit Ethernet is increasing as more manufacturers supply interfaces that conform to the specification published by DEC, Intel and Xerox With this increasing availability, more and more software is being written for these interfaces. There are two alternatives:</p>
<ol type="1">
<li>Every implementor invents his/her own method to do some form of address resolution</li>
<li>Every implementor uses a standard so that his/her code can be distibuted to other systems without need for modification.</li>
</ol>
<p>This proposal attempts to set the standard.</p>
<h1><a class="anchor" id="Definitions"></a>
Definitions</h1>
<p>Define the following for referring to the values put in the TYPE field of the Ethernet packet header:</p>
<ul>
<li>ether_type$XEROX_PUP</li>
<li>ether_type$DOD_INTERNET</li>
<li>ether_type$CHAOS</li>
<li>ether_type$ADDRESS_RESOLUTION</li>
</ul>
<p>Also define the following values (to be discussed later):</p>
<ul>
<li>ares_op$REQUEST (= 1, high byte trasmitted first)</li>
<li>ares_op$REPLY (= 2)</li>
<li>ares_hrd$Ethernet (= 1)</li>
</ul>
<h1><a class="anchor" id="PacketFormat"></a>
Packet Format</h1>
<p>To communicate mappings from &lt;protocol, address&gt; pairs to 48.bit Ethernet addresses, a packet format that embodies the Address Resolution protocol is needed. The format of the packet follows:</p>
<p>Ethernet transmission layer (not necessarily accessible to the user):</p>
<ul>
<li>48.bit: Ethernet address of destination</li>
<li>48.bit: Ethernet address of sender</li>
<li>16.bit: Protocol type = ether_type$ADDRESS_RESOLUTION</li>
</ul>
<p>Ethernet packet data:</p>
<ul>
<li>16.bit: (ar$hrd) Hardware address space (e.g., Ethernet, Packet Radio Net.)</li>
<li>16.bit: (ar$pro) Protocol address space. For Ethernet hardware, this if from the set of type fields ether_type$&lt;protocol&gt;.</li>
<li>8.bit: (ar$hln) byte length of each hardware address</li>
<li>8.bit: (ar$pln) byte length of each protocol address</li>
<li>16.bit: (ar$op) opcode (ares_op$REQUEST | ares_op$REPLY)</li>
<li>nbytes: (ar$sha) Hardware address of sender of this packet, n from the ar$pln field.</li>
<li>mbytes: (ar$spa) Protocol address of sender of this packet, m from the ar$pln field.</li>
<li>nbytes: (ar$tha) Hardware address of target of this packet (if known).</li>
<li>mbytes: (ar$tpa) Protocol address of target.</li>
</ul>
<h1><a class="anchor" id="PacketGeneration"></a>
Packet Generation</h1>
<p>As a packet is sent down through the network layers, routing determines the protocol address of the next hop for the packet and on which piece of hardware it expects to find the station with the immediate target protocol address. In the case of the 10Mbit Ethernet, address resolution is needed and some lower layer (probably the hardware driver) must consult the Address Resolution module (perhaps implemented in the Ethernet support module) to covert the &lt;protocol type, target protocol address&gt; pair to a 48.bit Ethernet address. The Address Resolution module tries to find this pair in a table. If it finds the pair, it gives the corresponding 48.bit Ethernet address back to the caller (hardware driver) which then transmits the packet. If it does not, it probably informs the caller that it is throwing the packet away (on the assumption the packet will be retransmitted by a higher network layer), and generates an Ethernet packet with a type field of ether_type$ADDRESS_RESOLUTiON. The Address Resolution module then sets the ar$hrd field to ares_hrd$Ethernet, ar$pro to the protocol type that is being resolved, ar$hln to 6 (the number of bytes in a 48.bit Ethernet address), ar$pln to the length of an address in that protocol, ar$op to ares_op$REQUEST, ar$sha with the 48.bit ethernet address of itself, ar$spa with the protocol address of itself, and ar$tpa with the protocol address of the machine that is trying to be accessed. It does not set ar$tha to anything in particular, because it is this value that it is trying to determine. It could set ar$tha to the broadcast address for the hardware (all ones in the case of the 10Mbit Ethernet) if that makes it convenient for some aspect of the implementation. It then causes this packet to be broadcast to all stations on the Ethernet cable originally determined by the routing mechanism.</p>
<h1><a class="anchor" id="PacketReception"></a>
Packet Reception</h1>
<p>When an address resolution packet is received, the receiving Ethernet module gives the packet to the Address Resolution module goes through an algorithm similar to the following. Negative conditionals indicate an end of processing and a discarding of the packet.</p>
<div class="fragment"><div class="line">Do I have the hardware type in ar$hrd?</div>
<div class="line">Yes: (almost defintely)</div>
<div class="line">     [optionally check the hardware length ar$hln]</div>
<div class="line">     Do I speak the protocol in ar$pro?</div>
<div class="line">     Yes:</div>
<div class="line">         [optionally check the protocol length ar$pln]</div>
<div class="line">         Merge_flag := <span class="keyword">false</span></div>
<div class="line">         If the pair &lt;protocol type, sender protocol address&gt; is already in my translation table, update</div>
<div class="line">         the sender hardware address field of the entry with the <span class="keyword">new</span> information in the packet and set</div>
<div class="line">         Merge_flag to <span class="keyword">true</span>.</div>
<div class="line">         Am I the target protocol address?</div>
<div class="line">         Yes:</div>
<div class="line">             If Merge_flag is <span class="keyword">false</span>, add the triplet &lt;protocol type, sender protocol address, sender hardware</div>
<div class="line">             address&gt; to the translation table.</div>
<div class="line">             Is the opcode ares_op$REQUEST? (NOW look at the opcode!!)</div>
<div class="line">             Yes:</div>
<div class="line">                 Swap hardware and protocol fields, putting the local hardware and protocl addresses in the</div>
<div class="line">                 sender fields.</div>
<div class="line">                 Set the ar$op field to ares_op$REPLY</div>
<div class="line">                 Send the packet to the (<span class="keyword">new</span>) target hardware address on the same hardware on which the</div>
<div class="line">                 request was received.</div>
</div><!-- fragment --><p>Notice that the &lt;protocol type, sender protocol address, sender hardware address&gt; triplet is merged into the table before the opcode is looked at. This is on the assumption that communication is bidirectional; if A has some reason to talk to B, then B will probably have some reason to talk to A. Notice also that if an entry already exists for the &lt;protocol type, sender protocol address&gt; pair, then the new hardware address supersedes the old one. Related Issues gives some motivatino for this.</p>
<p>Generalization: The ar$hrd and ar$hln field allow this protocl and packet format to be used for non-10Mbit Ethernets. For 10Mbit Ethernet &lt;ar$hrd, ar$hln&gt; takes on the value &lt;1, 6&gt;. For other hardware networks, the ar$pro field may no longer correspond to the Ethernet type field, but it should be associated with the protocol whose address resolution is being sought.</p>
<h1><a class="anchor" id="Why_is_it_done_This_way"></a>
Why is it done this way?</h1>
<p>Periodic broadcasting is definetely not desired. Imagine 100 workstations on a single Ethernet, each broadcasting address resolution information once per 10 minutes (as one possible set of parameters). This is one packet every 6 seconds. This is almost reasonable, but what use is it? The workstations aren't generally going to be talking to each other (and therefore have 100 useless entries in a table); they will be mainly talking to a mainframe, file server on bridge. but only to a small number of other workstations (for interactive conversations, for example). The protocol described in thsi paper distributes information as it is needed, and only once (probably) per boot of a machine.</p>
<p>This format does not allow for more than one resolution to be done in the same packet. This is for simplicity. If things were multiplexed the packet format would be considerably harder to digest, and much of the information could be gratuitous. Think of a bridge that talks four protocols telling a workstation all four protocol addresses, three of which the workstation will probably never use.</p>
<p>This format allows the packet buffer to be reused if a reply is generated; a reply has the same length as a request, and several of the fields are the same.</p>
<p>The value of hardware field (ar$hrd) is taken from a list for this purpose. Currently the only defined value it for the 10Mbit Ethernet (ares_hrd$Ethernet = 1). There has been talk of using this protocol for Packet Radio Networks as well, and this will require another value as will other future hardware mediums that wish to use this protocol.</p>
<p>For the 10Mbit Ethernet, the value in the protocol field (ar$pro) is taken from the set ehter_type$. This is a natural reuse of the assigned protocol types. Combining this with the opcode (ar$op) would effectively halve the number of protocols that can be resolved under this protocol and would make a monitor/debuffer more complex (see Network Monitoring and Debugging below). It is hoped that we will never see 32768 protocols, but Murphy made some laws which don't allow use to make this assumption.</p>
<p>In theory, the length fields (ar$hln and ar$pln) are redundant, since the length of a protocol address should be determined by the hardware type (found in ar$hrd) and the protocol type (foudn in ar$pro). It is included for optional consistency checking, and for network monitoring and debugging.</p>
<p>The opcode is to determine if this is a request (which amy cause a reply) or a reply to a previous request. 16 bits for this is overkill, but a flag (field) is needed.</p>
<p>The sender hardware address and sender protocol address are absolutely necessary. It is these fields that get put in a translation table.</p>
<p>The target protocol address is necessary in the request form of the packeet so that a machine can determine whether or not to enter the sender information in a table or to send a reply. It is not necessarily needed in the reply form if one assumes a reply is only provoked by a request. It is included for completeness, network monitoring, and to simplify the suggested processing algorithm described above (which does not look at the opcode until AFTER putting the sender information in a table).</p>
<p>The target hardware address is included for completeness and network monitoring. It has no meaning in the request form, since it is this number that the machine is requesting. ITs meaning in the reply form is the address of the machine makeing the request. In some implementations (which do not get to look at the 14.byte ethernet header, for example) this may save some register shuffling or stack space by sending this field to the hardware driver as the hardware destination address of the packet.</p>
<p>There are no padding bytes between addresses. The packet data should be viewed as a byte stream in which only 3 byte pairs are defined to be words (ar$hrd, ar$pro, and ar$op) which are sent most significant byte first (Ethernet/PDP-10 byte style).</p>
<h1><a class="anchor" id="NetworkMonitoring_and_Debugging"></a>
Network Monitoring and Debugging</h1>
<p>The above Address Resolution protocol allows a machine to gain knowledge about the higher level protocol activity (e.g., CHAOS, Internet PUP, DECnet) on an Ethernet cable. It can determine which Ethernet protocol type fields are in use (by value) and the protocol addresses within each protocol type. In fact, it is not necessary for the monitor to speak any of the higher level protocols involved. It goest something like this:</p>
<p>When a monitor receives an Address Resolution packet, it always enters the &lt;protocol type, sender hardware address&gt; in a table. It can determine the length of the hardware and protocol address from the ar$hln and ar$pln fields of the packet. If the opcode is a REPLY the monitor can then throw the packet away. If the opcode is a REQUEST and the target protocol address matches the protocol address of the monitor, the monitor sends a REPLY as it normally would. The monitor will only get one mapping this way, since the REPLY to the REQUEST will be sent directly to the requesting host. The monitor could try sending its own REQUEST, but this could get two monitors into a REQUEST sending loop, and care must be taken.</p>
<p>Because the protocol and opcode are not combined into one field, the monitor does not need to know which request opcode is associated with which reply opcode for the same higher level prtocol. The length fields should also give enough information to enable it to "parse" a protocol addresses, although it has no knowledge of what the protocol addresses mean.</p>
<p>A working implementation of the Address Resolution protocol can also be used to debug a non-working implementation. Presumably a hardware driver will successfully broadcast a packet with Ethernet type field of ether_type$ADDRESS_RESOLUTION. The format of the packet may not be totally correct, because initial implementations may have bugs, and table management may be slightly tricky. Because requests are broadcast a monitor will receive the packet and can display it for debugging if desired.</p>
<h1><a class="anchor" id="Example"></a>
An Example</h1>
<p>Let there exist machines X and Y that are on the same 10Mbit Ethernet cable. They have Ethernet address EA(X) and EA(Y) and DOD Internet addresses IPA(X) and IPA(Y). Let the Ethernet type of Internet be ET(IP). Machine X has just been started, and sooner or later wants to send an Internet packet to machine Y on the same cable. X knows that is wants to send to IPA(Y) and tells the hardware driver (here an Ethernet driver) IPA(Y) and tells the hardware driver (here an Ethernet driver) IPA(Y). The driver consults the Address Resolution module to convert &lt;ET(IP), IPA(Y)&gt; into a 48.bit Ethernet address, but because X was just started, it does not have this information. It throws the Internet packet away and instead creates an ADDRESS RESOLUTION packet with</p>
<div class="fragment"><div class="line">(ar$hrd) = ares_hrd$Ethernet</div>
<div class="line">(ar$pro) = ET(IP)</div>
<div class="line">(ar$hln) = length(EA(X))</div>
<div class="line">(ar$pln) = length(IPA(X))</div>
<div class="line">(ar$op)  = ares_op$REQUEST</div>
<div class="line">(ar$sha) = EA(X)</div>
<div class="line">(ar$spa) = IPA(X)</div>
<div class="line">(ar$tha) = don<span class="stringliteral">&#39;t care</span></div>
<div class="line"><span class="stringliteral">(ar$tpa) = IPA(Y)</span></div>
</div><!-- fragment --><p>and broadcasts this packet to everybody on the cable.</p>
<p>Machine Y gets this packet, and determines that it understands the hardware type (Ethernet), that it speaks the indicated protocol (Internet) and that the packet is for it ((ar$tpa)=IPA(Y)). It enters (probably replacing any existing entry) the information that &lt;ET(IP), IPA(X)&gt; maps to EA(X). It then notices that it is a request, so it swaps fields, putting EA(Y) in the new sender Ethernet address field (ar$sha), sets the opcode to reply, and sends the packet directly (not broadcast) to EA(X). At this point Y knows how to send to X, but X still doesn't know how to send to Y.</p>
<p>Mahcine X gets the reply packet from Y, forms the map from &lt;ET(IP), IPA(Y)&gt; to EA(Y), notices the packet is a reply and throws it away. The next time X's Internet module tries to send a packet to Y on the Ethernet, the translation will succeed, and the packet will (hopefully) arrive. If Y's Internet module then wants to talk to X, this will also succeed since Y has remembered the information form X's request for Address Resolution.</p>
<h1><a class="anchor" id="RelatedIssue"></a>
Related Issue</h1>
<p>It may be desirable to have table aging and/or timeouts. The implementation of these is outside the scope of this protocol.</p>
<p>If a host moves, any connection initiated by that host will working, assuming its own address resolution table is cleared when it moves. However, connections initiated to it by other hosts will have no particular reason to know to discard their old address. However, 48.bit Ethernet addresses are supposed to be unique and fixed for all time, so they shouldn't change. A host could "move" if a host name (and address in some other protocol) were reassigned to a different physical piece of hardware. Also, as we know from experience, there is always the danger of incorrect routing information accidentally getting transmitted through hardware or software error; it should not be allowed to persist forever. Perhaps failure to initiate a connection should inform the Address Resolution module to delete the information on the basis that the host is not reachable, possible because it is down or the old translation is no longer valid. Or perhaps receiving of a packet from a host should reset a timeout in the address resolution entry used for transmitting packets to that host; if no packets are received from a host for a suitable length of time, the address resolution entry is forgotten. This may cause extra overhead to scan the table for each incoming packet. Perhaps a hash or index can make this faster.</p>
<p>The suggested algorithm for receiving address resolution packets tries to lessen the time it takes for recovery if a host does move. Recall that if the &lt;protocol type, sender protocol address&gt; is already in the translation table, then the sender hardware address supersedes the existing entry. Therefore, on a perfect Ethernet where a broadcast REQUEST reaches all stations on the cable, each station will be get the new hardware address.</p>
<p>Another alternative is to have a daemon perform the timeouts. After a suitable time, the daemon considers removing an entry. It first sends (with a small number of retransmissions if needed) an address resolution packet with opcode REQUEST directly to the Ethernet address in the table. If a REPLY is not seen in a short amount of time, the entry is deleted. The request is sent directly so as not to bother every station on the Ethernet. Just forgetting entries will likely cause useful information to be forgotten, which must be regained.</p>
<p>Since hosts don't transmit information about anyone other than themselves, rebooting a host will cause its address mapping table to be up to date. Bad information can't persist forever by being passed around from machine to machine; the only bad information that can exist is in a machine that doesn't known that some other machien has changed its 48.bit Ethernet address. Perhaps manually resetting (or clearing) the address mapping table will suffice.</p>
<p>This issue clearly needs more thought if it is belived to be important. It is caused by any address resolution-liek protocol.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc826">Ethernet Address Resolution Protocol</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
